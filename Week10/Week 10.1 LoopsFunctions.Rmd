---
title: "Loops and Functions"
output: 
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
---

In this worksheet, we will:

-   Discuss ow to write a for loop to iterate through some process
-   Define the basic structure of functions
-   Include if/else statements to control the flow of loops/functions
-   Consider When loops/functions are or aren't useful tools

Because we always come back to `tidyverse`:

```{r}
library(tidyverse)
```

## 1. Loops

### a. Basic for-loops

Suppose you want to perform the same task over and over. You can use loops to perform iterative tasks with the following structure:

```{r, eval=FALSE}
for(i in sequence){
  # task
}
```

Let's consider this basic loop:

```{r}
# i takes the value of each element in the sequence 1,2,3,...,5
for(i in 1:5){
  print(i)
}
```

Printing is nice but what if we want to save the values generated by the loop into a vector? We would need to initialize such a vector and define each element:

```{r}
# Initialize an empty vector
myoutput <- c()

# Remember i takes the value of each element in the sequence 1,2,3,...,10
for(i in 1:5){
  # so we can use the values of i to index the new vector
  myoutput[i] <- i # the ith element is i
}

# Take a look!
myoutput
```

------------------------------------------------------------------------

#### **Try it! Find the mean of the squares for the numbers 1 through 10.**

```{r}
# Write and submit code here!
total = 0
index = 0
for (i in 1:10) {
  total = total + i^2
  index = index + 1
}
total = total/index
print(total)

mean((1:10)^2) # this is the one-liner, equal to the above function
```

------------------------------------------------------------------------

We can also define a specific vector (not necessarily numbers!) and go through each element of the vector:

```{r}
# Define a vector
basket <- c('Apple', 'Orange', 'Passion fruit', 'Banana')

# Apply a loop to go through each element of that vector
for(fruit in basket){ 
  print(str_length(fruit)) # fruit takes the value of each element in basket
}
```

We could also create an object to save each length in a vector BUT `str_length` can apply to vectors so we can just do:

```{r}
# A function already exists for doing that!
str_length(basket)
```

For-loops could slow down the computation. We prefer *vectorization* over for-loops since it results in shorter and clearer code. A vectorized function is a function that will apply the same operation on each value of the vectors.

### b. Conditional Statements

We can execute some code under certain conditions with the *if-else* structure:

```{r, eval=FALSE}
if (condition) {
  #code to run when condition is TRUE
  } else {
  #code to run when condition is FALSE
}
```

Let's try a basic example:

```{r}
# Set value of x
x <- 4  

# Test if x is less than 5 or not
if(x < 5){
  print("This number is less than five!")
} else {
  print("This number is at least five!")
}
```

Now what if we want to repeat this for several values? Use a for-loop!

```{r}
# What if x was 5
for (i in 1:5) { 	
  if(i < 5){
  print("This number is less than five!")
    } 
  else {
  print("This number is at least five!")
    }
} 
```

We can add many conditions!

```{r, eval=FALSE}
if (condition1){
  #code to run when condition1 is TRUE
  code
  } else if (condition2) {
  #code to run when condition2 is TRUE
  code
  }
  } else if (condition3) {
  #code to run when condition3 is TRUE
  code
  }
  } else {
  #code to run when all conditions are FALSE
  code
}
```

------------------------------------------------------------------------

## Group Practice

Consider the following dataset (get more information by running `?msleep` in the console):

```{r}
head(msleep)
```

We can obtain the names of the variables into a vector with `names`:

```{r}
names(msleep)
```

Using a for-loop, an if/else statement, and base R plots, make an appropriate plot for numeric variables and another type of plot that is appropriate for categorical variables.

```{r}
# Write code here
library(ggplot2)
for (variable in msleep) {
  if (is.numeric(variable)) {
    hist(variable)
  }
  else {
    barplot(table(variable))
  }
}
```

------------------------------------------------------------------------

How nice would that be if we could create these basic plots for investigating variables from any datasets?

## 2. Functions

Sometimes you will find yourself needing to perform the same operations over and over (like creating appropriate graphs to investigate variables). Functions are another way to perform repetitive tasks.

### a. R functions

All of the functions we have used in this course were written by someone and then integrated either into base R or an external package. Because R is open-source, you can check the documentation with `?function` or view the source code of any of these functions:

```{r}
View(fivenum)
```

Think of a few of your favorite functions and view the source code:

```{r}
# View some other functions:
View()
```

If all you see is *UseMethod( )*, it just means that the function name you specified has different versions for different classes of arguments. You can view all related functions with *methods( )*:

```{r}
View(mean)
methods(mean)
View(mean.default)
```

### b. Our own functions

Suppose we want to create our own function to either simplify a process we do often or to share with a collaborator.

To write our own functions, we need to:

-   Define the function **name** and what **arguments** it will take.
-   Specify the function **body** and **return**, enclosed within the function's {}.
-   Call the function which runs the function after it has been defined.

```{r, eval=FALSE}
# Structure of a function
function_name <- function(arguments){
  # perform operations on inputs and produce output
  body/return
}
```

Let's define a function for finding the sum of two numbers:

```{r}
mysum <- function(x,y){
  return(x+y)
}
```

Note that after running this function definition, it appears in the Environment. Now we can call the function:

```{r}
# Find some sums
mysum(2,6)
mysum(1:10,100)
```

------------------------------------------------------------------------

#### **Try it! Using your code from the previous group practice, create a function that makes an appriopate plot for each variable in a dataset depending on its type (numeric/categorical). Test your function with `msleep` and `mtcars`.**

```{r}
# Write code here
graph_cols = function(x) {
  for (variable in x) {
    if (is.numeric(variable)) {
      hist(variable)
    }
    else {
      barplot(table(variable))
    }
  }
}
graph_cols(msleep)
graph_cols(mtcars)
```

------------------------------------------------------------------------

## 3. Don't reinvent the wheel

There are many built-in functions in R that can make your programming easier. Look up the documentation or search forums to see if a function already exists before you build it.

One example for applying a function to all variables in the dataset:

```{r}
# Check out sapply
sapply(msleep[, sapply(msleep, is.numeric)], mean, na.rm = TRUE)
```

One example for creating univariate graphs for each variable in a dataset using a new package:

```{r}
# Install a new package
install.packages("DataExplorer")

# Load the library
library(DataExplorer)

# Plot dataset structure with appropriate graphs for each variable
plot_bar(msleep)        
plot_histogram(msleep)
```

------------------------------------------------------------------------

## Group Practice

Consider the following dataset (get more information by running `?quakes` in the console):

```{r}
head(quakes)
```

Suppose we want to find out what feature of an earthquake can impact its magnitude.

1.  Create a plot to compare each variable in `quakes` to the magnitude, `mag`. Which variable seems to have the strongest relationship with magnitude?

```{r}
# Write code here

```

2.  Define each variable in the dataset, except `mag`, as a categorical variable with low/high values: a low value refers to a value below the median for that variable, a high value refers to a value above the median for that variable. Call them `variablename_cat`.

```{r}
# Write code here

```

3.  Create a plot to compare each categorical variable to the magnitude. Which variable shows the largest difference in magnitude between low and high values?

```{r}
# Write code here

```

4.  Select the plots for what you think is 1) the best numeric variable associated with magnitude, 2) the best categorical variable showing differences in magnitude. Share them on your [group's slide] (<https://docs.google.com/presentation/d/1ZgCYrh-aSaPenIRh8I_oHvbHuWBfCWGOSB9ZbCTrG-M/edit?usp=sharing>)
